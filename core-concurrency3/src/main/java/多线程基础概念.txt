http://jcip.net.s3-website-us-east-1.amazonaws.com/listings.html

【主题：通过同步来避免多线程在同一时刻访问相同的数据】

竞态条件：
	由于多线程不恰当的执行时序导致出现不正确的结果，称为竞态条件 Race Condition
	当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件
	本质：基于一种可能随时失效的观察结果作为判断，或者执行某种计算
		----这种类型的竞态条件称为：先检查后执行：先判断是否为空，为空则xxx，否则yyy
		----Lazy Singleton就是这样的情况，先判断实例对象是否为空，如果为空则创建，否则直接返回该实例
	出现原因：cpu执行线程时，不可预测的执行时序
	解决办法：
		确保对竞态条件的原子性操作（Java确保原子性的内置机制-加锁）：
			1. 原子变量类  AtomicLong AtomicInteger ... 负责数值的原子性控制
			2. 使用同步：加锁

线程安全类
	无状态的类（没有成员变量的类）一定是线程安全的
	当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，则这个类仍然是线程安全的
	常见的加锁约定：
		将所有可变状态都封装到对象内部，并通过对象的内置锁对所有访问可变状态的路径进行同步，使得在该对象上不会发生并发访问。
	需要明确的是：并非所有的数据都需要加锁保护，只有被多线程同时访问的可变数据才需要加锁来保护。如，不变数据就不需要加锁！
	
同步机制/加锁机制
	锁：确保某段程序作为1个不可分割的单元被执行，没执行完就不释放锁，其它线程将被阻塞，无法进入。
	Java同步内置机制：
		线程进入同步代码块之前自动获取锁，退出代码块时自动释放锁。
		Java内置锁是一种互斥体（或互斥锁），1次最多1个线程能持有这个锁。
		当线程A进行同步代码块后，其它线程将获取不到锁，只能等待线程A释放锁后才能进入。
		其实，就是将并行执行的线程，在进入同步代码块的时候，变为串行的方式运行。
		线程释放锁定情况：执行完同步代码，或者该线程抛出异常退出该同步块
	
	用锁来保护共享状态：通过锁来构造线程间的协议：对共享状态的独占访问
	注意：锁必须唯一
		所有涉及共享状态访问（读、写），必须使用同一个锁才能达到同步的目的！！！
		某个线程获取锁之后，只能阻止其他线程获得同一个锁。其他线程获取另外的锁不会受到限制。
	
		
	一个重要的方面：可见性
	
	synchronized
		1. 同步代码块	锁：任何对象/this
			synchronized(this) {
				//访问或修改共享变量
			}
		2. 同步方法		锁：该类的对象this
			public synchronized void dosomething() {
				//访问或修改共享变量
			}
		3. 同步静态方法   锁：该类的Class对象
			public static synchronized void dosomething() {
				//访问或修改共享变量
			}
	
锁的可重入性
	如果某个线程试图获取1个已经由它自己获取的锁，则自动获取。
	锁的重入性：JVM记录获取到锁的线程，并将锁的获取次数加1，每次获取/重入都加1，退出则相应减少1，当计数器为0时，锁将被释放。	
	
安全问题--->性能问题	
	虽然加锁解决了多线程安全问题，但是加锁不当，会引发另一个问题：性能问题
	除非整个方法都在操作共享状态，否则最好不要加锁到方法级别上
	通过缩小同步代码的作用范围，既确保安全问题，又可保持了线程的并发性
	
	同步于并发的平衡：
		加锁范围尽量缩减，但不要分得过细：将本是原子操作的代码拆分到多个同步代码块中
		应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，让其它线程可以并发的执行这些分离出去的代码
	
	注意：如果某个操作长时间持有锁，将引发活跃性问题或性能问题！
		当执行时间较长的任务，无法快速完成的操作时（网络IO），一定不要持有锁！
		

【主题：如何共享和发布对象，从而使它们能够安全地由多线程同时访问】

同步有2个作用：	
	1.代码被原子性的执行：防止某个线程正在使用共享状态，而另一个线程在同时修改该状态
	2.内存可见性：当1个线程修改了对象状态后，其它线程能够看到共享状态发生的变化	

可见性
	当读操作和写操作在不同的线程中执行时，如果不使用同步机制，有可能执行读操作的线程无法看到其它线程写入的值
	为了确保多线程之间对内存写入操作的可见性，必须使用同步机制
	
编译器可能会重排程序的执行顺序
	在没有同步的情况下，编译器、处理器都可能对操作的执行顺序进行一些意想不到的调整。
	在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得到正确的结论！
	
	如何避免丢失可见性？
		只要数据在多线程之间共享，就使用正确的同步进行控制！
		
非原子的64位操作
	long double类型 8个字节  64bit
	这2种类型的数据，如果是非volatile的，JVM允许将64位的读写操作分解为2个32位的操作。
	当读取1个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，很可能读到某个值的高32位和另一个值的低32位
	因此，多线程共享可变的long和double类型变量也不安全。
	除非使用volatile进行声明，或者使用加锁保护起来。
		private volatile long count;
		private volatile double sum;
	volatile-不稳定的，易变的
		volatile主要为了确保更新的可见性：当变量被某个线程更新后，其它线程能看到更新后的值
		volatile并不能取代synchronized的同步机制，只有在简单的场景下才建议使用
	volatile的使用场景
		通常用作某个操作完成(done, working)、发生中断(isInterrupt, running)或者作为状态的标记(true/false)时才能使用
		而且确保只有1个线程对变量执行写操作
		而且该变量不会与其它变量一起纳入不变性条件(什么是不变量条件？)中
		而且访问该变量不需要加锁
		如：
		volatile boolean asleep; //标记
		while(!asleep) {
			counting();
		}
		
		private void counting() {
			//1,2,3...
		}
	
	volatile不足以确保递增操作(count++)的原子性,除非能确保只有1个线程对变量执行写操作
	原子变量(Atomic)作为"一种更好的volatile变量"，提供了"读-更新-写"的原子操作！
	
		
加锁与可见性
	加锁的含义不仅仅局限于互斥行为，还包括内存可见性。
	为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程，都必须在同一个锁上同步！
	加锁操作既可以确保可见性又可以确保原子性，而volatile变量只能保证可见性！
	

【发布与溢出】
	许多情况下，需要确保对象及其内部状态不被发布；
	某些情况下，又需要发布某个对象。如果发布，则要确保线程安全性，可能需要同步。
	
	发布：将1个指向该对象的引用暴露给外界/在1个非私有的方法中返回该对象的引用/将引用传入其它对象的方法中
	逸出：某个不应该发布的对象被发布就称为逸出
	
【线程封闭】
	当使用线程封闭技术时，通常是因为要将某个特定的子系统设计为1个单线程子系统，既有简单性，又能避免死锁
		
	不共享线程不安全的对象，将其封闭到线程内部：
	方式一：单线程读取线程不安全对象，每次获取1个新的分配给每个线程
		JDBC连接池，服务器通过单线程方式从连接池获取数据库连接（Connection不是线程安全的）
	
	方式二：栈封闭
		局部变量/对象，只对当前线程可见。变量位于线程栈中，其它线程无法访问栈
		栈封闭需要注意局部变量逸出，即不要直接或间接的返回这个变量的引用。
		
	方式三：ThreadLocal
		不共享状态（共享状态则需要同步），即不设置可变状态，将可变变量封装到线程内部，利用ThreadLocal实现
		ThreadLocal会在类之间引入隐含的耦合性，使用时需慎重考虑
		
【不变性】	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	【主题：java.util.concurrent类库】

	



		

	

	


