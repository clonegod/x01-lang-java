## zookeeper的功能与底层关键原理
![Image of zkcomponents](https://github.com/clonegod/tools/blob/master/images/zkcomponents.jpg)
>PAXOS 算法 - 一种基于消息传递的一致性算法
>
>ZAB 原子消息广播 - 分布式环境中保证数据的一致性。
>
>zk集群某个节点发生写操作时，会挂起当前客户端请求，并阻塞新达到的请求。
>当前处理写请求的节点会通过ZAB协议将数据复制给集群中的其它节点，直到集群中所有节点都完成了数据同步操作，集群处于一致性状态时，才向客户端返回结果，然后继续处理新的请求。ZAB算法就是要解决集群节点间如何复制数据，实现所有节点数据的一致性。

zookeeper是一个高可用的分布式管理与协调框架，基于ZAB算法(原子消息广播协议)的实现。

也就是基于这样的特性，使得zookeeper成为了解决分布式一致性问题的利器！

该框架能够很好的保证分布式环境中数据的一致性。

#### 顺序一致性
从一个客户端发起的事务请求，最终会严格的按照其发起的顺序被应用到zookeeper集群中。
#### 原子性
所有事务请求的处理结果，在整个集群的所有机器上的应用情况是一致的。

要么整个集群所有机器都成功应用了某一事务，要么都没有应用。

一定不会出现部分机器应用了事务，而另一部分没有应用的情况发生。

#### 单一视图
无论客户端连接到zk集群中的哪个节点上，其看到的服务端数据模式都是一致的。

#### 可靠性
一旦服务器成功应用了某个事务，并完成了对客户端的响应，那么该事务所引起的服务器状态将被一直保留下来。除非有另一个事务对其进行了修改。

#### 实时性
通常所说的实时性指的是一旦事务被成功的应用了，那么客户端就能立刻从服务器上获取到变更后的数据。

zookeeper能保证在一段时间内，客户端最终一定能从服务器读取到最新的数据(网络延迟等原因导致数据延迟)。

###### 特别说明
zk适合存储少量的数据信息，比如配置信息、服务注册信息、发布订阅的信息等。


## zookeeper的组成
zookeeper根据身份分为3种类型： **Leader，Follower，Observer**

其中，Follower和Observer又称为Learner（学习者）。

	Leader：负责处理客户端的write请求；
	Follower：负责处理客户端的read请求，参数Leader选举；
	Observer：特殊的“Follower”，不参与选举，专门处理客户端的read请求，提高zk集群整体的读取速度。
	


## zookeeper的特性
**简单的数据结构**

zookeeper以简单的树形结构（znode节点树）来组织内部数据，也叫树形名称空间。

**集群方式运行**

一般zookeeper集群由一组节点组成，3-5台机器就可以组成一个zookeeper集群。

只要集群中超过半数的节点在运行，那么整个集群就能对外提供正常的服务。

**顺序访问**

对于每个客户端的每一个请求，zookeeper都会分配全局唯一的递增编号。

这个编号反应了所有事务操作的先后顺序。应用程序可以使用zookeeper的这个特性来实现更高层次的同步逻辑。

**高性能**

由于zookeeper将全量数据存储在内存中，并直接服务于所有非事务请求（非事务请求指的就是只读请求，不涉及数据的写操作。写操作需要操作本地文件，所以性能差一些）。

因此，在读操作为主的场景下性能非常优秀。在Jmeter压力测试下（100%读请求场景），结果约12W QPS。







	


	