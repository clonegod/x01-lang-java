应用程序之间通信可分为同步通信和异步通信。

【同步通信】
使用RMI、 Hessian、 Burlap、 HTTP invoker和Web服务在应用程序之间进行通信。 
所有这些通信机制都是同步的， 客户端应用程序直接与远程服务相交互， 并且一直等到远程过程完成后才继续执行。
通信是同步的， 客户端必须等待服务完成！

【异步通信】
异步消息是一个应用程序向另一个应用程序间接发送消息的一种方式， 这种方式无需等待对方的响应。 
客户端不需要等待服务处理消息， 甚至不需要等待消息投递完成。 
客户端发送消息， 然后继续执行其它程序， 这是因为客户端假定服务最终可以收到并处理这条消息。

间接性也是异步消息的关键所在。 当一个应用向另一个应用发送消息时， 两个应用之间没有直接的联系。 

异步消息中有两个主要的概念： 消息代理（message broker） 和目的地（destination） 。 
当一个应用发送消息时， 会将消息交给一个消息代理。 消息代理实际上类似于邮局。 
消息代理可以确保消息被投递到指定的目的地， 同时解放发送者， 使其能够继续进行其他的业务。
每条异步消息都带有一个目的地， 目的地就好像一个邮箱。

目的地只关注消息应该从哪里获得——而不关心是由谁取走消息的。 


=====================================================================

【消息模型】

两种通用的目的地： 队列（queue） 和主题（topic） 。 
每种类型都与特定的消息模型相关联， 分别是点对点模型（队列） 和发布/订阅模型（主题） 。

点对点消息模型-queue	-> 1个消息只能被1个接收者处理	-> 邮局投递(1:1)
	消息队列对消息发送者和消息接收者进行了解耦。
	每一条消息都有一个发送者和一个接收者。
	队列可以有多个接收者， 但是每一条消息只能被一个接收者取走。
	$$$在点对点的消息中， 如果有多个接收者监听队列， 无法知道某条特定的消息会由哪一个接收者处理。 
	这种不确定性实际上有很多好处， 因为我们只需要简单地为队列添加新的监听器就能提高应用的消息处理能力。

发布—订阅消息模型-topic	-> 1个消息可以被N个接收者处理	-> 杂志订阅 (1:N)
	主题可以将消息发送者与消息接收者进行解耦。
	消息会发送给一个主题。 与队列类似， 多个接收者都可以监听一个主题。
	与队列不同的是， 消息不再是只投递给一个接收者， 而是主题的所有订阅者都会接收到此消息的副本。
	$$$发布者并不知道谁订阅了它的消息。 发布者只知道它的消息要发送到一个特定的主题，而不知道有谁在监听这个主题。 
	
评估异步消息的优点
	客户端无需等待
		客户端只需要将消息发送给消息代理，不需要等待， 所以客户端可以继续执行其他任务，客户端的性能能够极大的提高。
	客户端面向消息和解耦
		RPC通信是面向方法的调用， 发送异步消息是以数据为中心的。
	位置独立
		客户端只需要了解需要通过哪个队列或主题来发送消息。
		点对点模型中：
			 可以利用这种位置的独立性来创建服务的集群。 可以配置多个服务从同一个队列中接收消息。 
			如果服务过载， 处理能力不足， 我们只需要添加一些新的服务实例来监听相同的队列就可以了
		发布-订阅模型中：
			多个服务可以订阅同一个主题， 接收相同消息的副本。 但是每一个服务对消息的处理逻辑却可能有所不同。
			设我们有一组服务可以共同处理描述新员工信息的消息。
			 一个服务可能会在工资系统中增加该员工， 另一个服务则会将新员工增加到HR门户中， 同时还有一个服务为新员工分配可访问系统的权限。
			  每一个服务都基于相同的数据（都是从同一个主题接收的） ， 但各自进行独立的处理。 
	确保投递
		当发送异步消息时， 客户端完全可以相信消息会被投递。 
		即使在消息发送时， 服务无法使用， 消息也会被存储起来， 直到服务重新可以使用为止。

=====================================================================

在Spring中使用‘消息队列’发送和接收消息。
	Java消息服务：（Java Message Service，JMS） 
	高级消息队列协议：（Advanced Message Queuing Protocol，AMQP） 
	
JMS定义的是API规范
	JMS的API协议能够确保所有的实现都能通过通用的API来使用， 但是并不能保证某个JMS实现所发送的消息能够被另外不同的JMS实现所使用。 
	使用JMS的话， 只有两种消息模型可供选择： 点对点和发布-订阅。
	在JMS中， 有三个主要的参与者： 
		消息的生产者、 消息的消费者以及在生产者和消费者之间传递消息的通道（队列或主题） 。
	 
	 
使用AMQP实现消息功能
	AMQP为消息定义了线路层（wire-level protocol） 的协议。
	AMQP的线路层协议规范了消息的格式， 消息在生产者和消费者间传送的时候会遵循这个格式。 
	这样AMQP在互相协作方面就要优于JMS——它不仅能跨不同的AMQP实现， 还能跨语言和平台。
	
	AMQP的生产者并不会直接将消息发布到队列中。
	AMQP在消息的生产者以及传递信息的队列之间引入了一种间接的机制： Exchange。 	
	消息的生产者将信息发布到一个Exchange。 Exchange会绑定到一个或多个队列上， 它负责将信息路由到队列上。 信息的消费者会从队列中提取数据并进行处理。
	
	四种标准的AMQP Exchange如下所示：
		Direct： 如果消息的routing key与binding的routing key直接匹配的话， 消息将会路由到该队列上；
		Topic： 如果消息的routing key与binding的routing key符合通配符匹配的话， 消息将会路由到该队列上；
		Headers： 如果消息参数表中的头信息和值都与bingding参数表中相匹配， 消息将会路由到该队列上；
		Fanout： 不管消息的routing key和参数表的头信息/值是什么， 消息将会路由到所有队列上。
	
	借助这四种类型的Exchange， 可以定义任意数量的路由模式， 而不再仅限于点对点和发布-订阅的方式。
	Exchange根据生产者发生所消息附带的routing key来决定消息路由到哪里。
	
=====================================================================
消息系统允许软件、应用相互连接和扩展．这些应用可以相互链接起来组成一个更大的应用。
消息系统通过将消息的发送和接收分离来实现应用程序的异步和解偶．

或许你想要实现数据投递，非阻塞操作或推送通知，发布／订阅，异步处理，或者工作队列。所有这些都可以通过消息系统实现。

RabbitMQ是一个消息代理 - 一个消息系统的媒介。
	它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全。



	