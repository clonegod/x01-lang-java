【JVM底层原理】
1、虚拟机基本概念
虚拟机内部组成：
	类加载器：从文件系统或网络加载class字节码文件，加载的信息存放在一块称为方法去的内存空间。
	方法区：存放类的元数据信息，静态常量，常量池，字符串字面量等。
	java堆：在java虚拟机启动的时候建立java堆，是java程序最主要的内存工作区域，几乎所有对象实例都是存放到java堆中的，堆空间被所有java线程共享。
	直接内存：java的NIO库允许java程序使用直接内存，从而提高性能。通常，直接内存速度优于java堆，读写频繁的场景下可以考虑使用。
	线程栈：每个虚拟机线程都有一个私有的栈空间，一个线程的java栈在线程创建的时候被创建。java栈中保存着局部变量，方法参数，方法调用入栈、返回值等。
	本地方法栈：用于本地方法的调用，java虚拟机允许直接调用本地方法（通常为c语言编写）。
	垃圾收集系统：java提供一套进行垃圾清理的机制，开发人员无需手动清理系统垃圾，由gc系统自动处理。
	寄存器：线程私有，java虚拟机会每个线程创建一个pc寄存器，在任意时刻，一个java线程总是在执行一个方法，这个方法称为当前方法。
	执行引擎：虚拟机最核心的组件，负责执行虚拟机的字节码。一般，会将字节码编译为机器码后执行。
	
	
2、jvm内存模型
	主要弄清楚三块：堆、栈、方法区。
	堆：新生代（Eden+Survivor）、老年代
		java堆是和java应用程序关系最密切的内存空间，几乎所有的对象都存放在堆内存中。并且java堆是完全自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要程序员手动释放。
		根据垃圾回收机制的不同，java堆可能拥有不同的结构。最为常见的就是将整个java堆分为新生代和老年代。
		其中，新生代存放新创建的对象或者年龄不大的对象，老年代存放老年对象。
		新生代分为eden区，s0区，s1区，s0和s1也被称为from和to区域，它们是两块大小相等且可以互换角色的空间。
		绝大多数情况下，对象首先分配到eden区，在1次新生代回收后，如果对象还存活，则会进入s0或s1区，之后每经过一次新生代的回收，如果对象存活则年龄+1，当对象达到一定年龄后，进入老年代区域。
			
	栈：
		java栈是线程私有的内存空间。一个栈，一般由三部分组成：局部变量表，操作数栈，帧数据区。
		栈帧：一个方法入栈就属于一个栈帧。
		
	方法区：
		方法区是线程共享的内存区域。
		保存系统的类信息，比如类的字段，方法，常量池。
		方法区的大小决定了虚拟机可以保存多少个类，如果系统定义的类太多（第三方框架创建大量的代理类），导致方法区溢出，虚拟机也会抛出内存溢出错误。PermOutOfMemory
		方法区可以理解为永久区（Perm）。
	
	
3、常用虚拟机参数
虚拟机参数的配置，分为以下几方面，
	1、堆内存空间的分配
		堆内存大小：
			初始堆：-Xms ，比如 -Xms5m . 为了减少新生代gc次数，可直接将-Xms大小与-Xmx设置为相同的大小。
			最大堆：-Xmx，比如-Xmx10m
			新生代: -Xmn，这个参数对系统性能以及GC行为有很大的影响(较大的新生代会减少老年代的大小)。
				   	新生代一般设置为整个堆空间的1/3或1/4左右.
				   	-Xmn: 按绝对大小来设置新生代的大小
				   	-XX:NewRatio 按比例分配新生代和老年代大小，-XX:NewRatio=老年代/新生代
			survivor: -XX:SurvivorRatio, 设置新生代中eden空间和from/to空间的比例，
				比如 eden/from=eden/to=8，则from或to占整个新生代的1/10
		栈空间大小：-Xss ，比如-Xss512k
		方法区大小：-XX:PermSize -XX:PermMaxSize
	2、垃圾回收器的配置
		-XX:+UseSerialGC	串行回收器
	3、其它
		-XX:+PrintGC		虚拟机启动后，只要有GC，就会打印GC日志
		-XX:+PrintGCDetails	查看GC前后各个区的内存使用情况，提供更细节的GC日志
		-XX:+PrintCommandLineFlags	将隐式或显示传给虚拟机的参数输出，以便了解jvm启动时具体使用了哪些配置参数。
		
4、垃圾回收概念、算法，对象的分代转换过程
	jvm什么时候进行gc?
		触发时机：分配给虚拟机的内存（新生代、老年代）快用完了，
		新生代内存满时触发minorGC，老年代内存满时触发majorGC.
		java的垃圾收集根据当前系统运行的内存使用情况，包括当前应用系统的性能表现等因素，综合考虑什么时候需要执行gc，具体执行由jvm来控制。
	垃圾收集算法：
		引用计数法 - jvm未采用
			存在循环引用的问题。
		复制算法 - 新生代 s0 -> s1 
			复制算法的核心思想：
			将内存空间分为两块，每次只使用其中一块，在垃圾收集时，将正在使用的内存中的存活对象复制到未被使用的那块内存中，
			然后清除之前正在使用的内存块中的所有对象，反复交换两个内存块的角色，完成垃圾收集。
			java中from和to空间就是使用复制算法来完成存活对象的保存。
		标记清除算法 - 
			分为标记和清除两个阶段完成内存中垃圾的清理。
			该方式存在的弊端是存在内存碎片问题，垃圾回收后内存空间是不连续的，不连续内存空间的工作效率要低于连续内存空间。
			老年代 并发回收器CMS，在若干次并发清除之后，仍然需要进行内存碎片整理，用来解决内存碎片的问题。
		标记压缩算法 - 老年代
			在标记清除算法的基础上进行了优化，将存活对象压缩到内存的一端，然后再进行垃圾清理。
			老年代使用标记压缩算法
		分代算法 - 新生代 与 老年代 
			根据对象的特点把内存划分为N块，对每个块使用不同的垃圾回收算法。
			对于新生代和老年代来说，新生代回收频率高，但是每次回收耗时都很短；
			而老年代垃圾回收耗时会相对更长（对象多且内存空间大），所以应该尽量减少老年代的GC频率。
		分区算法 - G1
			将整个内存分为N个小的独立空间，每个小的空间都可以独立使用。
			通过细粒度的内存划分，可以控制1次仅对一部分小空间进行回收，而不是对整个内存空间进行GC，从而提升性能，减少GC的停顿时间。
	
	垃圾回收时的系统停顿现象-STW stop the world
		垃圾回收器的任务是识别和回收垃圾对象，进行内存清理，以便释放出内存空间，避免发生内存溢出错误。
		为了让垃圾回收器可以高效的执行，大部分情况下，会要求系统进入一个停顿状态（所有用户线程都被暂停），这有这样系统才不会有新的垃圾产生。
		同时，保证系统在垃圾回收时保持一致性状态，有益于更好的进行垃圾标记。
		因此，在垃圾回收过程中，都会出现应用系统的停顿现象。
		不同的垃圾回收算法，对系统停顿影响也有不同的影响。
		
	对象是如何从新生代进行老年代的？
		1、基于对象年龄来控制-经历多少次majorGC
			对象首次创建会被放到新生代Eden区存放
			在新生代每次GC之后，如果对象没有被回收则年龄加1，对象年龄由GC的次数来决定。
			一旦对象年龄达到一定大小，就会自动从新生代进入到老年代。
			虚拟机提供了一个参数，用来控制新生代对象的年龄大小，当超过该值就会晋升到老年代：-XX:MaxTenuringThreshold，默认值为15.
		2、大对象直接进入老年代
			如果新创建的对象比较大，超过新生代Eden区可用内存空间时，该对象会直接进入老年代。
		3、手动设置对象大小
			有一个参数可以设置对象大小超过多少时直接放入老年代（即使新生代可以空间可以容纳该对象）：-XX:PretenureSizeThreshold
			比如，设置-XX:PretenureSizeThreshold=1024000，即超过1M的对象直接放入老年代。
		
		
5、垃圾收集器
	串行垃圾回收器（SerialGC + SerialOldGC）：
		使用单线程进行垃圾回收，每次回收时，只有1个线程进行垃圾清理工作。
		串行回收器可以在新生代和老年代使用，根据作用于不同的堆，分为新生代串行回收器和老年代串行回收器。
		适用于单核cpu的场景下使用。
		使用-XX:UseSerialGC 参数可以设置使用新生代串行回收器和老年代串行回收期。
	
	并行垃圾回收器/与cms搭配使用，对新生代进行并行回收（ParNewGC）：
		并行回收器在串行回收器的基础上做了改进，可以使用多个线程进行垃圾回收。
		可以看作是Serial回收器的升级版，提供多线程并行垃圾回收，该收集器主要是为了与CMS并发回收器搭配使用。
		对于计算能力强的计算机，可以有效缩短垃圾回收所需的实际时间。
		ParNew回收器是一个工作在新生代的垃圾回收器，它只是简单的将串行回收器多线程化，它的回收策略和算法与串行回收器是相同的。
		使用-XX:UseParNewGC 可以设置新生代使用并行回收器，老年代则使用串行回收器。
		指定并行线程数；
			ParNew回收器的工作线程数可以使用-XX:ParallelGCThreads参数指定。一般，最好设置为cpu的核数，避免过多线程影响垃圾收集的速度。
	
	并行垃圾回收器/关注系统吞吐量（ParallelGC + ParallelOldGC）：
		以多线程独占方式进行垃圾回收。侧重于提高系统吞吐量。
		使用-XX:+UseParallelGC 可以设置新生代使用并行回收器，新生代使用复制算法
		使用-XX:+UseParallelOldGC 可以设置老年代使用并行回收器，老年代使用标记压缩算法。
		提供了两个非常关键的参数来控制系统吞吐量：
			-XX:MaxGCPauseMillis
				设置最大垃圾收集停顿时间，可以将虚拟机在GC停顿的时间控制在MaxGCPauseMillis范围内。
				如果希望减少GC停顿的时间，可以将该值调小，但是会导致更频繁的GC，导致GC总时间的增加，降低了系统吞吐量。
				所以，需要根据实际情况设置该值。
			-XX:GCTimeRatio	
				设置吞吐量的大小，它是一个0到100之间的整数。
				默认99，即系统将花费不超过1/(1+n)的时间用于垃圾回收，也就是1/(1+99)=1%的时间。
		另外，还可以指定 -XX:+UseAdaptiveSizePolicy
			打开自适应模式，在这种模式下，新生代的大小，eden区、from/to的比例，以及晋升老年代的对象年龄参数会被自动调整，以达到堆大小，吞吐量和停顿时间的平衡点。
	
	并发垃圾回收器/关注减少系统停顿时间（CMS）：
		CMS全称为Concurrent Mark Sweep 并发标记清除，使用标记清除算法，主要关注系统停顿时间。
		使用-XX:+UseConcMarkSweepGC 进行设置。
		使用-XX:ConcGCThreads 设置并发线程数量。
		CMS并不是独占的回收器，也就是说CMS在回收的过程中，应用程序仍然在不停的工作，又会有新的垃圾不断的产生。
		所以，在使用CMS的过程中，应该确保应用程序有足够的内存空间可用，也就是说在执行CMS垃圾回收时，应该预留足够内存给应用程序使用
        ----怎样预留空间呢？在老年代空间使用68%的时候，就开始启动CMS执行垃圾回收，而不是等到内存快用完时才进行。
        ----所以，CMS回收器需要在老年代使用约2/3的时候就启动，剩下的1/3的内存就预留给用户线程使用的“预留内存空间”！！！
		CMS不会等到老年代内存饱和的时候才进行垃圾回收，而是在达到某一阈值的时候就开始执行回收。
		CMS触发的阈值：
			-XX:CMSInitiationOccupancyFraction
				通过这个参数可以配置回收阈值 ，默认值是68，即当老年代的空间使用率达到68%的时候，会执行CMS回收。
				调小该值，可以让CMS更早的触发，降低老年代被占满的可能，但是会引起更频繁的触发CMS回收器。
				如果应用负载比较低，在生产环境上年老代的增长非常缓慢，因此可以设置此参数为80，以降低CMS触发的几率。
			如果内存使用增长很快，在CMS执行的过程中，已经出现内存不足的情况，此时CMS回收就会失败（Concurrent mode failed），此时虚拟机将启动串行回收器对老年代进行垃圾回收，
			这将导致应用程序中断，直到垃圾回收完成后才会恢复用户线程，这个过程GC的停顿时间比较长。
			所以，-XX:CMSInitiatingOccupancyFraction的设置需要根据实际情况进行设置。
		解决内存碎片问题的相关参数：
			-XX:+UseCMSCompactAtFullCollection	设置CMS垃圾回收后，进行1次内存碎片整理。整理过程是独占的，会引起系统停顿。
			-XX:CMSFullGCsBeforeCompaction	设置进行多少次CMS回收之后，对老年代内存进行1次碎片整理。
		
	G1回收器：
		G1回收器（Garbage-First）是在jdk1.7中提出的垃圾回收器，但是在jdk1.7中还不成熟，
		在jdk1.8中被应用为默认的垃圾回收器。从长期目标来看，是为了取代CMS回收器。
		G1回收器拥有独特的垃圾回收策略，G1属于分代垃圾回收器，区分新生代和老年代，依然有eden和from/to区，并不要求eden区或新生代、老年代的空间连续性，因为它使用了分区算法。
		并行性：G1回收期间可以多线程并行工作。
		并发性：G1拥有与应用程序并行执行的能力，部分工作可以与应用程序同时执行，在整个GC期间不会完全阻塞应用程序。
		分代GC：G1依然是一个分代收集器。但兼顾新生代和老年代一起进行垃圾回收，即G1既可以回收新生代，也可以回收老年代。（之前的垃圾收集器都只能对一个区进行垃圾收集，要么是对新生代，要么是对老年代）
		空间整理：G1在回收过程中，不会向CMS那样在若干次GC后需要进行碎片整理，G1采用了有效的复制对象的方式，减少空间碎片。
		可预见性：由于采用分区算法，将整个内存划分为了N个独立的小块内存，每个内存块是独立的，G1可以只选取部分区域进行回收，缩小了回收的范围，提升了垃圾回收的性能。
		使用-XX:+UseG1GC	使用G1回收器
		使用-XX:MaxGCPauseMillis	指定允许的最大系统停顿时间
		使用-XX:ParallelGCThreads 设置并行回收的线程数量
		
